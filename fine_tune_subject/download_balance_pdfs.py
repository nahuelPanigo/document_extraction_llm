"""
Download PDFs for balancing the dataset based on the IDs generated by balance_dataset.py
"""
import pandas as pd
import requests
import os
import time
from pathlib import Path
from constants import PDF_FOLDER, CSV_FOLDER, DOWNLOAD_URL, PDF_URL
from utils.colors.colors_terminal import Bcolors

def load_ids_to_download():
    """Load the list of IDs to download from the balance analysis"""
    balance_dir = CSV_FOLDER / "balance_downloads"
    ids_file = balance_dir / "all_ids_to_download.txt"
    
    if not ids_file.exists():
        print(f"{Bcolors.FAIL}IDs file not found: {ids_file}{Bcolors.ENDC}")
        print(f"{Bcolors.WARNING}Please run balance_dataset.py first!{Bcolors.ENDC}")
        return []
    
    with open(ids_file, 'r') as f:
        ids = [line.strip() for line in f if line.strip()]
    
    print(f"{Bcolors.OKGREEN}Loaded {len(ids)} IDs to download{Bcolors.ENDC}")
    return ids

def transform_id(doc_id):
    """Transform ID from handle format to path format"""
    return doc_id.replace("-", "/")

def make_request(url, file_path, doc_id):
    """
    Download a single PDF file with error handling and rate limiting
    """
    try:
        response = requests.get(url, timeout=30)
        
        if response.status_code == 200:
            with open(file_path, 'wb') as f:
                f.write(response.content)
            print(f"{Bcolors.OKGREEN}✓ Downloaded: {doc_id}{Bcolors.ENDC}")
            return True
            
        elif response.status_code == 429:  # Rate limited
            print(f"{Bcolors.WARNING}Rate limited for {doc_id}. Waiting 10 seconds...{Bcolors.ENDC}")
            time.sleep(10)
            return False  # Will retry
            
        else:
            print(f"{Bcolors.FAIL}✗ Failed {doc_id}: HTTP {response.status_code}{Bcolors.ENDC}")
            return True  # Don't retry other HTTP errors
            
    except requests.exceptions.RequestException as e:
        print(f"{Bcolors.FAIL}✗ Error downloading {doc_id}: {e}{Bcolors.ENDC}")
        return True  # Don't retry connection errors

def get_ids_not_downloaded(ids):
    """Filter out IDs that already have PDFs downloaded"""
    if not PDF_FOLDER.exists():
        PDF_FOLDER.mkdir(parents=True, exist_ok=True)
        return ids
    
    existing_pdfs = set()
    for pdf_file in PDF_FOLDER.glob("*.pdf"):
        # Extract ID from filename (assuming format: id.pdf)
        pdf_id = pdf_file.stem
        existing_pdfs.add(pdf_id)
    
    ids_needed = [id for id in ids if id not in existing_pdfs]
    
    print(f"{Bcolors.OKBLUE}Already downloaded: {len(ids) - len(ids_needed)}{Bcolors.ENDC}")
    print(f"{Bcolors.OKBLUE}Still need to download: {len(ids_needed)}{Bcolors.ENDC}")
    
    return ids_needed

def download_files(ids):
    """
    Download PDF files for the given IDs
    """
    if not ids:
        print(f"{Bcolors.OKGREEN}No files to download!{Bcolors.ENDC}")
        return
    
    print(f"{Bcolors.HEADER}=== Starting PDF Download ==={Bcolors.ENDC}")
    print(f"Target folder: {PDF_FOLDER}")
    
    # Ensure PDF folder exists
    PDF_FOLDER.mkdir(parents=True, exist_ok=True)
    
    downloaded = 0
    failed = 0
    
    for i, doc_id in enumerate(ids, 1):
        print(f"\n{Bcolors.HEADER}[{i}/{len(ids)}] Processing: {doc_id}{Bcolors.ENDC}")
        
        # Transform ID for URL
        transformed_id = transform_id(doc_id)
        
        # Construct URL
        url = f"{PDF_URL}{transformed_id}/Documento_completo.pdf?sequence=1&isAllowed=y"
        
        # Construct file path
        file_path = PDF_FOLDER / f"{doc_id}.pdf"
        
        # Skip if already exists
        if file_path.exists():
            print(f"{Bcolors.OKBLUE}Already exists: {doc_id}{Bcolors.ENDC}")
            continue
        
        print(f"URL: {url}")
        
        # Download with retry logic for rate limiting
        max_retries = 3
        retry_count = 0
        
        while retry_count < max_retries:
            success = make_request(url, file_path, doc_id)
            
            if success:
                if file_path.exists():
                    downloaded += 1
                else:
                    failed += 1
                break
            else:
                retry_count += 1
                print(f"{Bcolors.WARNING}Retry {retry_count}/{max_retries} for {doc_id}{Bcolors.ENDC}")
        
        if retry_count >= max_retries:
            print(f"{Bcolors.FAIL}✗ Max retries exceeded for {doc_id}{Bcolors.ENDC}")
            failed += 1
        
        # Small delay between requests to be respectful
        time.sleep(1)
    
    print(f"\n{Bcolors.HEADER}=== Download Summary ==={Bcolors.ENDC}")
    print(f"{Bcolors.OKGREEN}Downloaded: {downloaded}{Bcolors.ENDC}")
    print(f"{Bcolors.FAIL}Failed: {failed}{Bcolors.ENDC}")
    print(f"{Bcolors.OKBLUE}Total processed: {len(ids)}{Bcolors.ENDC}")

def show_download_progress():
    """Show current download progress by subject"""
    balance_dir = CSV_FOLDER / "balance_downloads"
    summary_file = balance_dir / "download_summary.csv"
    
    if not summary_file.exists():
        print(f"{Bcolors.WARNING}No download summary found. Run balance_dataset.py first.{Bcolors.ENDC}")
        return
    
    df = pd.read_csv(summary_file)
    
    print(f"\n{Bcolors.HEADER}=== Download Progress by Subject ==={Bcolors.ENDC}")
    
    for _, row in df.iterrows():
        subject = row['subject']
        total_needed = row['ids_to_download']
        ids_list = row['ids_list'].split(',') if row['ids_list'] else []
        
        # Count how many are already downloaded
        downloaded_count = 0
        for doc_id in ids_list:
            pdf_path = PDF_FOLDER / f"{doc_id}.pdf"
            if pdf_path.exists():
                downloaded_count += 1
        
        progress = (downloaded_count / total_needed * 100) if total_needed > 0 else 0
        print(f"  {subject}:")
        print(f"    Progress: {downloaded_count}/{total_needed} ({progress:.1f}%)")

def main():
    """Main function to download balance PDFs"""
    print(f"{Bcolors.HEADER}=== PDF Download for Dataset Balancing ==={Bcolors.ENDC}")
    
    # Show current progress
    show_download_progress()
    
    # Load IDs to download
    ids_to_download = load_ids_to_download()
    
    if not ids_to_download:
        return
    
    # Filter out already downloaded files
    ids_needed = get_ids_not_downloaded(ids_to_download)
    
    if not ids_needed:
        print(f"{Bcolors.OKGREEN}All files already downloaded!{Bcolors.ENDC}")
        show_download_progress()
        return
    
    # Confirm download
    print(f"\n{Bcolors.WARNING}About to download {len(ids_needed)} PDF files.{Bcolors.ENDC}")
    response = input("Continue? (y/N): ")
    
    if response.lower() not in ['y', 'yes']:
        print(f"{Bcolors.OKBLUE}Download cancelled.{Bcolors.ENDC}")
        return
    
    # Download files
    download_files(ids_needed)
    
    # Show final progress
    print(f"\n{Bcolors.OKGREEN}Download complete!{Bcolors.ENDC}")
    show_download_progress()

if __name__ == "__main__":
    main()